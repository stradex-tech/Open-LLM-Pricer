const bcrypt = require("bcryptjs");

const { adminExists, createUser } = require("../db");
const { auditLog } = require("../audit");

function normalizeToken(v) {
  return typeof v === "string" ? v.trim() : "";
}

function sessionRegenerate(req) {
  return new Promise((resolve, reject) => {
    if (!req?.session?.regenerate) return resolve();
    req.session.regenerate((err) => (err ? reject(err) : resolve()));
  });
}

function sessionSave(req) {
  return new Promise((resolve, reject) => {
    if (!req?.session?.save) return resolve();
    req.session.save((err) => (err ? reject(err) : resolve()));
  });
}

function registerSetupRoutes(app, { setupToken } = {}) {
  const expectedSetupToken = normalizeToken(setupToken);
  const setupTokenRequired = Boolean(expectedSetupToken);

  app.get("/api/setup/status", (_req, res) => {
    const ag = String(process.env.SESSION_SECRET_AUTOGENERATED || "").toLowerCase();
    const ps = String(process.env.SESSION_SECRET_PERSISTED || "").toLowerCase();
    const sessionSecretAutogenerated = ag === "1" || ag === "true" || ag === "yes";
    const sessionSecretPersisted = ps === "1" || ps === "true" || ps === "yes";
    return res.json({
      admin_exists: adminExists(),
      session_secret_autogenerated: sessionSecretAutogenerated,
      session_secret_persisted: sessionSecretPersisted,
      setup_token_required: setupTokenRequired
    });
  });

  app.post("/api/setup/admin", async (req, res) => {
    try {
      if (adminExists()) {
        return res.status(400).json({ error: "Admin already exists" });
      }

      if (setupTokenRequired) {
        const got =
          normalizeToken(req?.headers?.["x-setup-token"]) ||
          normalizeToken(req?.body?.setupToken) ||
          normalizeToken(req?.body?.setup_token);
        if (!got || got !== expectedSetupToken) {
          return res.status(403).json({ error: "Invalid setup token" });
        }
      }

      const { username, password } = req.body || {};
      if (typeof username !== "string" || username.trim().length < 3) {
        return res.status(400).json({ error: "Username must be at least 3 characters" });
      }
      if (typeof password !== "string" || password.length < 8) {
        return res.status(400).json({ error: "Password must be at least 8 characters" });
      }

      const uname = username.trim();
      const hash = await bcrypt.hash(password, 10);
      const id = createUser({ username: uname, passwordHash: hash, role: "admin" });

      // Prevent session fixation by regenerating the session on initial setup.
      await sessionRegenerate(req);
      req.session.userId = id;
      req.session.userRole = "admin";
      // createUser sets updated_at to "now" (seconds)
      req.session.userUpdatedAt = Math.floor(Date.now() / 1000);
      await sessionSave(req);
      auditLog({
        req,
        actorUserId: id,
        actorUsername: uname,
        actorRole: "admin",
        action: "setup.create_admin",
        entityType: "user",
        entityId: String(id),
        success: true,
        details: { username: uname, role: "admin" }
      });
      return res.json({ ok: true, user: { id, username: uname, role: "admin" } });
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      return res.status(500).json({ error: message });
    }
  });
}

module.exports = { registerSetupRoutes };

