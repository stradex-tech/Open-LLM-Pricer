const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const express = require("express");
const session = require("express-session");

const { priceFromImage, ollamaProbe } = require("./ollama");
const { SqliteSessionStore } = require("./session-store");
const { adminExists, getPriceMemoryRetentionDays, getPriceMemoryHit, putPriceMemory } = require("./db");
const { getSessionUser, requireAuth } = require("./auth");
const { registerSetupRoutes } = require("./routes/setup");
const { registerAuthRoutes } = require("./routes/auth");
const { registerAdminRoutes } = require("./routes/admin");
const { registerAuditRoutes } = require("./routes/audit");
const { auditFromReqUser } = require("./audit");
const { createRateLimiter } = require("./rate-limit");

const app = express();

function normalizeKeyPart(v, maxLen) {
  const s = String(v || "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim()
    .replace(/[^a-z0-9 ]+/g, ""); // keep alphanumerics + spaces for stable keys
  if (!s) return "";
  const out = s.length > maxLen ? s.slice(0, maxLen) : s;
  return out.trim();
}

function buildHintMemoryKey({ brand, itemModel, sku }) {
  const skuN = normalizeKeyPart(sku, 120);
  if (skuN) return `sku:${skuN}`;
  const b = normalizeKeyPart(brand, 80);
  const m = normalizeKeyPart(itemModel, 120);
  if (b && m) return `bm:${b}|${m}`;
  return "";
}

function buildBrandModelMemoryKey({ brand, model }) {
  const b = normalizeKeyPart(brand, 80);
  const m = normalizeKeyPart(model, 120);
  if (b && m) return `bm:${b}|${m}`;
  return "";
}

function getEnv(name, fallback) {
  const v = process.env[name];
  return typeof v === "string" && v.trim() ? v.trim() : fallback;
}

// ---- Security: SESSION_SECRET is used to sign login session cookies.
// If not provided (or weak/default), we auto-generate a strong random secret ONCE, persist it under ./data,
// and reuse it on future starts.
//
// This keeps first-run setup smooth while keeping a stable secret for sessions across restarts.
// (If the user deletes ./data, sessions will reset.)
let sessionSecret = typeof process.env.SESSION_SECRET === "string" ? process.env.SESSION_SECRET.trim() : "";
const isDefaultSecret = sessionSecret === "change-me" || sessionSecret === "dev-secret-change-me";
function isStrongSecret(s) {
  const v = typeof s === "string" ? s.trim() : "";
  if (!v) return false;
  if (v.length < 16) return false;
  if (v === "change-me" || v === "dev-secret-change-me") return false;
  return true;
}

function getDataDir() {
  const dataDir = path.join(__dirname, "..", "data");
  try {
    fs.mkdirSync(dataDir, { recursive: true });
  } catch {
    // ignore
  }
  return dataDir;
}

function getPersistedSecretPath() {
  return path.join(getDataDir(), "session_secret.txt");
}

function readPersistedSecret() {
  try {
    const p = getPersistedSecretPath();
    if (!fs.existsSync(p)) return "";
    const v = fs.readFileSync(p, "utf8").trim();
    return v;
  } catch {
    return "";
  }
}

function persistSecretOnce(secret) {
  const p = getPersistedSecretPath();
  try {
    // Create only if it doesn't exist.
    fs.writeFileSync(p, `${secret}\n`, { encoding: "utf8", mode: 0o600, flag: "wx" });
    return true;
  } catch (e) {
    // If another process created it, that's fine.
    if (String(e?.code || "").toUpperCase() === "EEXIST") return false;
    return false;
  }
}

const providedSecretValid = isStrongSecret(sessionSecret) && !isDefaultSecret;
if (!providedSecretValid) {
  // Try to reuse a previously-generated persistent secret from ./data.
  const persisted = readPersistedSecret();
  if (isStrongSecret(persisted)) {
    sessionSecret = persisted;
    process.env.SESSION_SECRET_PERSISTED = "true";
    process.env.SESSION_SECRET_AUTOGENERATED = "true";
    // eslint-disable-next-line no-console
    console.warn(
      [
        "",
        "[SECURITY] SESSION_SECRET not set; using persisted secret from ./data/session_secret.txt.",
        "To override, set SESSION_SECRET in your environment or a local .env.",
        ""
      ].join("\n")
    );
  } else {
    // First run: generate and persist.
    sessionSecret = crypto.randomBytes(32).toString("hex");
    const wrote = persistSecretOnce(sessionSecret);
    process.env.SESSION_SECRET_AUTOGENERATED = "true";
    process.env.SESSION_SECRET_PERSISTED = wrote ? "true" : "false";
    // eslint-disable-next-line no-console
    console.warn(
      [
        "",
        "[SECURITY] SESSION_SECRET is missing/weak/default. Generated a strong secret and saved it to ./data/session_secret.txt.",
        "This keeps sessions stable across restarts (unless ./data is deleted).",
        "To manage it explicitly, set SESSION_SECRET in your environment or a local .env.",
        ""
      ].join("\n")
    );
  }
}

// ---- Security: First-run setup token protects /api/setup/admin from LAN takeover before an admin exists.
// If SETUP_TOKEN is provided explicitly, we use it and do not print it.
// Otherwise, on first boot (when no admin exists), we generate a strong token once and persist it under ./data/setup_token.txt,
// and print it so the operator can complete setup.
function getPersistedSetupTokenPath() {
  return path.join(getDataDir(), "setup_token.txt");
}
function isStrongSetupToken(s) {
  const v = typeof s === "string" ? s.trim() : "";
  // Hex(32 bytes) is 64 chars; accept >= 24 chars to allow operator-chosen tokens too.
  return Boolean(v && v.length >= 24);
}
function readPersistedSetupToken() {
  try {
    const p = getPersistedSetupTokenPath();
    if (!fs.existsSync(p)) return "";
    return fs.readFileSync(p, "utf8").trim();
  } catch {
    return "";
  }
}
function persistSetupTokenOnce(token) {
  const p = getPersistedSetupTokenPath();
  try {
    fs.writeFileSync(p, `${token}\n`, { encoding: "utf8", mode: 0o600, flag: "wx" });
    return true;
  } catch (e) {
    if (String(e?.code || "").toUpperCase() === "EEXIST") return false;
    return false;
  }
}
let setupToken = getEnv("SETUP_TOKEN", "");
const setupTokenProvided = isStrongSetupToken(setupToken);
if (!setupTokenProvided) {
  const persisted = readPersistedSetupToken();
  if (isStrongSetupToken(persisted)) {
    setupToken = persisted;
  } else if (!adminExists()) {
    setupToken = crypto.randomBytes(32).toString("hex");
    const wrote = persistSetupTokenOnce(setupToken);
    // eslint-disable-next-line no-console
    console.warn(
      [
        "",
        "[SECURITY] First-run setup token generated.",
        "Use this token to create the initial admin account at /setup:",
        `SETUP_TOKEN=${setupToken}`,
        wrote ? "(Token persisted to ./data/setup_token.txt)" : "(Token could not be persisted; it may change on restart.)",
        ""
      ].join("\n")
    );
  } else {
    // Admin exists; no need for setup token, but keep any persisted token if present.
    setupToken = persisted;
  }
}

// If you're behind a reverse proxy (nginx/caddy/traefik), set TRUST_PROXY=true
// so req.ip and secure cookies behave correctly.
if (process.env.TRUST_PROXY === "true") {
  app.set("trust proxy", 1);
}

app.disable("x-powered-by");

// Basic security headers (keeps UI working with inline scripts/styles).
app.use((req, res, next) => {
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("Referrer-Policy", "no-referrer");
  res.setHeader("Permissions-Policy", "camera=(self), microphone=(), geolocation=()");
  res.setHeader(
    "Content-Security-Policy",
    [
      "default-src 'self'",
      "base-uri 'self'",
      "frame-ancestors 'none'",
      "object-src 'none'",
      "img-src 'self' data: blob:",
      "style-src 'self'",
      "script-src 'self'",
      "connect-src 'self'",
      "form-action 'self'"
    ].join("; ")
  );
  return next();
});

app.use(express.json({ limit: "15mb" }));

app.use(
  session({
    name: "olp.sid",
    secret: sessionSecret,
    resave: false,
    saveUninitialized: false,
    store: new SqliteSessionStore(),
    cookie: {
      httpOnly: true,
      sameSite: "lax",
      secure: process.env.COOKIE_SECURE === "true",
      maxAge: 7 * 24 * 60 * 60 * 1000
    }
  })
);

// ---- CSRF: per-session token, required for state-changing /api/* requests.
function ensureCsrfToken(req, _res, next) {
  try {
    if (req?.session && typeof req.session.csrfToken !== "string") {
      req.session.csrfToken = crypto.randomBytes(32).toString("hex");
    }
  } catch {
    // ignore
  }
  return next();
}

function requireCsrf(req, res, next) {
  const method = String(req?.method || "GET").toUpperCase();
  if (method === "GET" || method === "HEAD" || method === "OPTIONS") return next();
  // Only enforce on API endpoints.
  if (!String(req?.path || "").startsWith("/api/")) return next();

  const expected = req?.session?.csrfToken;
  if (!expected || typeof expected !== "string") return res.status(403).json({ error: "CSRF token missing" });

  const headerToken = typeof req?.headers?.["x-csrf-token"] === "string" ? req.headers["x-csrf-token"].trim() : "";
  const bodyToken =
    typeof req?.body?.csrfToken === "string"
      ? req.body.csrfToken.trim()
      : typeof req?.body?.csrf_token === "string"
        ? req.body.csrf_token.trim()
        : "";
  const got = headerToken || bodyToken;

  if (!got || got !== expected) return res.status(403).json({ error: "Invalid CSRF token" });
  return next();
}

app.use(ensureCsrfToken);
app.get("/api/csrf", (req, res) => {
  return res.json({ ok: true, csrfToken: req?.session?.csrfToken || null });
});
app.use(requireCsrf);

// ---- Boot routing (no static index.html)
const publicDir = path.join(__dirname, "..", "public");

// Prevent direct access to admin HTML/JS via the static file server.
// Admin pages should be reachable via /admin, /admin/users, /admin/audit only.
const adminStaticPaths = new Set([
  "/admin.html",
  "/admin-users.html",
  "/admin-audit.html",
  "/admin.js",
  "/admin-common.js",
  "/admin-rules.js",
  "/admin-users.js",
  "/admin-audit.js"
]);
app.use((req, res, next) => {
  try {
    if (!adminStaticPaths.has(String(req?.path || ""))) return next();
    if (!adminExists()) return res.redirect("/setup");
    Promise.resolve(getSessionUser(req))
      .then((user) => {
        if (!user) return res.redirect("/login");
        if (user.role !== "admin") return res.redirect("/app");
        return next();
      })
      .catch(() => res.redirect("/login"));
  } catch {
    return res.redirect("/login");
  }
});
app.use(express.static(publicDir, { index: false }));

app.get("/", async (req, res) => {
  if (!adminExists()) return res.redirect("/setup");
  const user = await getSessionUser(req);
  if (!user) return res.redirect("/login");
  return res.redirect(user.role === "admin" ? "/admin" : "/app");
});

app.get("/setup", async (req, res) => {
  if (adminExists()) return res.redirect("/login");
  const user = await getSessionUser(req);
  if (user) return res.redirect(user.role === "admin" ? "/admin" : "/app");
  return res.sendFile(path.join(publicDir, "setup.html"));
});

app.get("/login", async (req, res) => {
  if (!adminExists()) return res.redirect("/setup");
  const user = await getSessionUser(req);
  if (user) return res.redirect(user.role === "admin" ? "/admin" : "/app");
  return res.sendFile(path.join(publicDir, "login.html"));
});

app.get("/app", async (req, res) => {
  if (!adminExists()) return res.redirect("/setup");
  const user = await getSessionUser(req);
  if (!user) return res.redirect("/login");
  if (user.role === "admin") return res.redirect("/admin");
  return res.sendFile(path.join(publicDir, "app.html"));
});

app.get("/admin", async (req, res) => {
  if (!adminExists()) return res.redirect("/setup");
  const user = await getSessionUser(req);
  if (!user) return res.redirect("/login");
  if (user.role !== "admin") return res.redirect("/app");
  return res.sendFile(path.join(publicDir, "admin.html"));
});

app.get("/admin/users", async (req, res) => {
  if (!adminExists()) return res.redirect("/setup");
  const user = await getSessionUser(req);
  if (!user) return res.redirect("/login");
  if (user.role !== "admin") return res.redirect("/app");
  return res.sendFile(path.join(publicDir, "admin-users.html"));
});

app.get("/admin/audit", async (req, res) => {
  if (!adminExists()) return res.redirect("/setup");
  const user = await getSessionUser(req);
  if (!user) return res.redirect("/login");
  if (user.role !== "admin") return res.redirect("/app");
  return res.sendFile(path.join(publicDir, "admin-audit.html"));
});

app.get("/healthz", (_req, res) => res.json({ ok: true }));

// Quick debug endpoint to verify the container can reach Ollama.
app.get("/api/ollama", requireAuth, async (_req, res) => {
  try {
    const info = await ollamaProbe();
    res.json({ ok: true, ...info });
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    // eslint-disable-next-line no-console
    console.error("[/api/ollama] error:", err);
    res.status(500).json({ ok: false, error: message });
  }
});

registerSetupRoutes(app, { setupToken: isStrongSetupToken(setupToken) ? setupToken : "" });
registerAuthRoutes(app);
registerAdminRoutes(app);
registerAuditRoutes(app);

const priceLimiter = createRateLimiter({
  // Vision pricing requests are expensive; keep this conservative.
  windowMs: Number(process.env.PRICE_RATE_WINDOW_MS ?? 60_000),
  max: Number(process.env.PRICE_RATE_MAX ?? 30)
});

app.post("/api/price", priceLimiter, requireAuth, async (req, res) => {
  const body = req.body || {};
  const bypassRequested = Boolean(body?.bypassPriceMemory);
  const brand = body?.brand;
  const make = body?.make;
  const itemModel = body?.itemModel;
  const sku = body?.sku;

  const b = typeof brand === "string" ? brand : typeof make === "string" ? make : "";
  const m = typeof itemModel === "string" ? itemModel : "";
  const s = typeof sku === "string" ? sku : "";

  try {
    const imageBase64 = body?.imageBase64;
    if (!imageBase64 || typeof imageBase64 !== "string") {
      if (bypassRequested) {
        auditFromReqUser(req, {
          action: "price.memory.bypass",
          entityType: "price",
          success: false,
          details: {
            error: "Missing imageBase64",
            hints: { brand: Boolean(b.trim()), itemModel: Boolean(m.trim()), sku: Boolean(s.trim()) },
            hint_lengths: { brand: b.trim().length, itemModel: m.trim().length, sku: s.trim().length }
          }
        });
      }
      auditFromReqUser(req, {
        action: "price.request",
        success: false,
        details: { error: "Missing imageBase64" }
      });
      return res.status(400).json({ error: "Missing imageBase64" });
    }

    const bypass = bypassRequested;
    const retentionDays = getPriceMemoryRetentionDays();

    // ---- Pricing memory (hybrid: user hints first, else model-provided brand+model)
    // If bypassing, do not read from memory (but still store after).
    const hintKey = buildHintMemoryKey({ brand: b, itemModel: m, sku: s });
    if (!bypass && hintKey) {
      const hit = getPriceMemoryHit(hintKey, retentionDays);
      if (hit) return res.json(hit);
    }

    const result = await priceFromImage({
      imageBase64,
      hints: {
        // Backwards-compatible: accept `make` if sent by older clients.
        brand: b,
        itemModel: m,
        sku: s
      }
    });

    const modelKey = !hintKey ? buildBrandModelMemoryKey({ brand: result?.brand, model: result?.model }) : "";
    if (!bypass && !hintKey && modelKey) {
      const hit = getPriceMemoryHit(modelKey, retentionDays);
      if (hit) return res.json(hit);
    }

    // If bypass button used, log only that event (no cache hit/miss logging).
    if (bypass) {
      auditFromReqUser(req, {
        action: "price.memory.bypass",
        entityType: "price",
        success: true,
        details: {
          hints: { brand: Boolean(b.trim()), itemModel: Boolean(m.trim()), sku: Boolean(s.trim()) },
          hint_lengths: { brand: b.trim().length, itemModel: m.trim().length, sku: s.trim().length }
        }
      });
    }

    // Store under strongest available keys for future consistent results.
    const hintsJson = { brand: b, itemModel: m, sku: s };
    if (hintKey) putPriceMemory(hintKey, result, hintsJson, retentionDays);
    if (modelKey) putPriceMemory(modelKey, result, hintsJson, retentionDays);
    auditFromReqUser(req, {
      action: "price.request",
      entityType: "price",
      success: true,
      details: {
        hints: { brand: Boolean(b.trim()), itemModel: Boolean(m.trim()), sku: Boolean(s.trim()) },
        hint_lengths: { brand: b.trim().length, itemModel: m.trim().length, sku: s.trim().length },
        result: {
          object: result?.object ?? null,
          confidence: result?.confidence ?? null,
          tiers: result?.tiers ?? null
        }
      }
    });
    return res.json(result);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    // eslint-disable-next-line no-console
    console.error("[/api/price] error:", err);
    if (bypassRequested) {
      auditFromReqUser(req, {
        action: "price.memory.bypass",
        entityType: "price",
        success: false,
        details: {
          error: message,
          hints: { brand: Boolean(b.trim()), itemModel: Boolean(m.trim()), sku: Boolean(s.trim()) },
          hint_lengths: { brand: b.trim().length, itemModel: m.trim().length, sku: s.trim().length }
        }
      });
    }
    auditFromReqUser(req, {
      action: "price.request",
      success: false,
      details: { error: message }
    });
    return res.status(500).json({ error: message });
  }
});

const port = Number(process.env.PORT || 3000);
const listenHost = getEnv("LISTEN_HOST", "0.0.0.0");
app.listen(port, listenHost, () => {
  // eslint-disable-next-line no-console
  console.log(`Open LLM Pricer listening on http://${listenHost}:${port}`);
});

